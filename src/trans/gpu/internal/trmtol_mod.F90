! (C) Copyright 1995- ECMWF.
! (C) Copyright 1995- Meteo-France.
! (C) Copyright 2022- NVIDIA.
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!

MODULE TRMTOL_MOD
  USE BUFFERED_ALLOCATOR_MOD
  IMPLICIT NONE

  PRIVATE
  PUBLIC :: TRMTOL_CUDAAWARE, PREPARE_TRMTOL, TRMTOL_HANDLE

  TYPE TRMTOL_HANDLE
    TYPE(ALLOCATION_RESERVATION_HANDLE) :: HPFBUF
  END TYPE
CONTAINS
  FUNCTION PREPARE_TRMTOL(ALLOCATOR, KF_LEG) RESULT(HTRMTOL)
    USE PARKIND_ECTRANS, ONLY: JPIM, JPRBT, JPIB
    USE TPM_DISTR, ONLY: D

    IMPLICIT NONE

    TYPE(BUFFERED_ALLOCATOR), INTENT(INOUT) :: ALLOCATOR
    INTEGER(KIND=JPIM), INTENT(IN) :: KF_LEG
    TYPE(TRMTOL_HANDLE) :: HTRMTOL

    REAL(KIND=JPRBT) :: DUMMY

    HTRMTOL%HPFBUF = RESERVE(ALLOCATOR, 2_JPIB*D%NLENGT0B*KF_LEG*SIZEOF(DUMMY), "HTRMTOL%HPFBUF")
  END FUNCTION

  SUBROUTINE TRMTOL_CUDAAWARE(ALLOCATOR,HTRMTOL,PFBUF_IN,PFBUF,KF_LEG)
    !**** *trmtol * - transposition in Fourier space

    !     Purpose.
    !     --------
    !              Transpose Fourier buffer data from partitioning
    !              over wave numbers to partitioning over latitudes.
    !              It is called between direct FFT and direct Legendre
    !              transform.
    !              This routine is the inverse of TRLTOM.


    !**   Interface.
    !     ----------
    !        *call* *trmtol(...)*

    !        Explicit arguments : PFBUF  - Fourier coefficient buffer. It is
    !        --------------------          used for both input and output.
    !                             KF_LEG - Number of fields communicated

    !        Implicit arguments :
    !        --------------------

    !     Method.
    !     -------
    !        See documentation

    !     Externals.
    !     ----------

    !     Reference.
    !     ----------
    !        ECMWF Research Department documentation of the IFS

    !     Author.
    !     -------
    !        MPP Group *ECMWF*

    !     Modifications.
    !     --------------
    !        Original : 95-10-01
    !        Modified : 97-06-17 G. Mozdzynski - control MPI mailbox use
    !                                            (NCOMBFLEN) for nphase.eq.1
    !        Modified : 99-05-28  D.Salmond - Optimise copies.
    !        Modified : 00-02-02  M.Hamrud  - Remove NPHASE
    !        D.Salmond : 01-11-23 LIMP_NOOLAP Option for non-overlapping message
    !                             passing and buffer packing
    !        G.Mozdzynski: 08-01-01 Cleanup
    !        Y.Seity   : 07-08-31 add barrier synchronisation under LSYNC_TRANS
    !     ------------------------------------------------------------------

    USE PARKIND_ECTRANS  ,ONLY : JPIM     ,JPRBT, JPIB
    USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK, JPHOOK
    USE MPL_MODULE  ,ONLY : MPL_ALLTOALLV, MPL_BARRIER, MPL_ALL_MS_COMM, MPL_MYRANK, MPL_ABORT
    USE TPM_DISTR       ,ONLY : D, NPRTRW, NPROC, MYPROC, MYSETW
    USE TPM_GEN         ,ONLY : LSYNC_TRANS
    USE MPI
    USE TPM_STATS, ONLY : GSTATS => GSTATS_NVTX

    IMPLICIT NONE

    INTEGER(KIND=JPIM) ,INTENT(IN)  :: KF_LEG
    REAL(KIND=JPRBT), INTENT(OUT), POINTER  :: PFBUF(:)
    REAL(KIND=JPRBT), INTENT(IN) :: PFBUF_IN(:)

    INTEGER(KIND=JPIM) :: ILENS(NPRTRW),ILENR(NPRTRW)
    INTEGER(KIND=JPIB) :: IOFFS(NPRTRW),IOFFR(NPRTRW)
    INTEGER(KIND=JPIM) :: J, FROM_SEND, TO_SEND, FROM_RECV, TO_RECV, IRANK
    INTEGER(KIND=JPIB) :: ILEN, ISTA, IEND
    REAL(KIND=JPHOOK) :: ZHOOK_HANDLE
    INTEGER(KIND=JPIM) :: IERROR
#ifdef HUGE_ARRAYS
    INTEGER(KIND=JPIB) :: I0, I1
#endif

    TYPE(BUFFERED_ALLOCATOR), INTENT(IN) :: ALLOCATOR
    TYPE(TRMTOL_HANDLE), INTENT(IN) :: HTRMTOL

    #ifdef PARKINDTRANS_SINGLE
    #define TRMTOL_DTYPE MPI_REAL
    #else
    #define TRMTOL_DTYPE MPI_DOUBLE_PRECISION
    #endif

    IF (LHOOK) CALL DR_HOOK('TRMTOL_CUDAAWARE',0,ZHOOK_HANDLE)

    CALL ASSIGN_PTR(PFBUF, GET_ALLOCATION(ALLOCATOR, HTRMTOL%HPFBUF),&
        & 1_JPIB, 2_JPIB*D%NLENGT0B*KF_LEG*SIZEOF(PFBUF(1)))

    IF(NPROC > 1) THEN
      DO J=1,NPRTRW
        ILENS(J) = 2_JPIB*D%NLTSFTB(J)*KF_LEG
        IOFFS(J) = 2_JPIB*D%NSTAGT1B(J)*KF_LEG
        ILENR(J) = 2_JPIB*D%NLTSGTB(J)*KF_LEG
        IOFFR(J) = 2_JPIB*D%NSTAGT0B(J)*KF_LEG
      ENDDO

      CALL GSTATS(807,0)

      ! copy to self workaround
      IRANK = MPL_MYRANK(MPL_ALL_MS_COMM)
      IF (ILENS(IRANK) .ne. ILENR(IRANK)) THEN
          PRINT *, "ERROR", ILENS(IRANK), ILENR(IRANK)
          stop 1
      ENDIF
      IF (ILENS(IRANK) > 0) THEN
          FROM_SEND = IOFFS(IRANK) + 1
          TO_SEND = FROM_SEND + ILENS(IRANK) - 1
          FROM_RECV = IOFFR(IRANK) + 1
          TO_RECV = FROM_RECV + ILENR(IRANK) - 1
          !$ACC KERNELS ASYNC(1) DEFAULT(NONE) PRESENT(PFBUF,PFBUF_IN)
          PFBUF(FROM_RECV:TO_RECV) = PFBUF_IN(FROM_SEND:TO_SEND)
          !$ACC END KERNELS
          ILENS(IRANK) = 0
          ILENR(IRANK) = 0
      ENDIF

      IF (LSYNC_TRANS) THEN
        CALL GSTATS(440,0)
        CALL MPL_BARRIER(MPL_ALL_MS_COMM,CDSTRING='')
        CALL GSTATS(440,1)
      ENDIF
      CALL GSTATS(421,0)
      IF (ANY(INT(IOFFR,KIND=JPIM) /= INT(IOFFR,KIND=JPIB))) CALL MPL_ABORT("Overflow in trmtol")
      IF (ANY(INT(IOFFS,KIND=JPIM) /= INT(IOFFS,KIND=JPIB))) CALL MPL_ABORT("Overflow in trmtol")
      !$ACC HOST_DATA USE_DEVICE(PFBUF_IN, PFBUF)
      CALL MPI_ALLTOALLV(PFBUF_IN,ILENS,INT(IOFFS,KIND=JPIM),TRMTOL_DTYPE,&
       & PFBUF,ILENR,INT(IOFFR,KIND=JPIM),TRMTOL_DTYPE,&
       & MPL_ALL_MS_COMM,IERROR)
      !$ACC END HOST_DATA
      IF (LSYNC_TRANS) THEN
        CALL GSTATS(441,0)
        CALL MPL_BARRIER(MPL_ALL_MS_COMM,CDSTRING='')
        CALL GSTATS(441,1)
      ENDIF
      CALL GSTATS(421,1)

      !$ACC WAIT(1)
      CALL GSTATS(807,1)
    ELSE
      ILEN = 2_JPIB*D%NLTSGTB(MYSETW)*KF_LEG
      ISTA = 2_JPIB*D%NSTAGT0B(MYSETW)*KF_LEG+1
      IEND = ISTA + ILEN - 1
      CALL GSTATS(1608,0)
#ifdef HUGE_ARRAYS
      !$ACC PARALLEL LOOP GANG ASYNC(1) DEFAULT(PRESENT)
      DO I1=1,2_JPIB*D%NLENGT0B
        !$ACC LOOP VECTOR
        DO I0=1,KF_LEG
          PFBUF(I0+(I1-1)*KF_LEG) = PFBUF_IN(I0+(I1-1)*KF_LEG)
        ENDDO
      ENDDO
      !$ACC END PARALLEL LOOP
#else
      !$ACC KERNELS ASYNC(1) DEFAULT(NONE) PRESENT(PFBUF,PFBUF_IN)
      PFBUF(ISTA:IEND) = PFBUF_IN(ISTA:IEND)
      !$ACC END KERNELS
#endif
      CALL GSTATS(1608,1)
    ENDIF

    IF (LHOOK) CALL DR_HOOK('TRMTOL_CUDAAWARE',1,ZHOOK_HANDLE)

    !     ------------------------------------------------------------------
  END SUBROUTINE TRMTOL_CUDAAWARE
END MODULE TRMTOL_MOD
